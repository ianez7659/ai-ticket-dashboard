from .db import engine
from .models import Base
from fastapi import FastAPI, Depends
from sqlalchemy.orm import Session
from .db import get_db
from .models import Ticket
from fastapi.middleware.cors import CORSMiddleware
import uuid
import os
from openai import OpenAI
from dotenv import load_dotenv
from .models import ActivityLog


load_dotenv()
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))


Base.metadata.create_all(bind=engine)

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, specify your frontend URL here
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

def log_action(db, ticket_id, action_text):
    log = ActivityLog(
        ticket_id=ticket_id,
        action=action_text
    )
    db.add(log)
    db.commit()


@app.get("/")
def root(db: Session = Depends(get_db)):
    return {"msg": "DB connected ðŸš€"}

@app.post("/tickets")
def create_ticket(title: str, description: str = "", name: str = "", email: str = "", db: Session = Depends(get_db)):
    new_ticket = Ticket(
        title=title,
        description=description,
        name=name if name else None,
        email=email if email else None
    )

    db.add(new_ticket)
    db.commit()
    log_action(db, new_ticket.id, "Ticket created")

    db.refresh(new_ticket)

    return {
        "id": str(new_ticket.id),
        "title": new_ticket.title,
        "status": new_ticket.status
    }

# Get most recently created tickets
# This should be located above the "/tickets/{ticket_id}" route to avoid conflicts
@app.get("/tickets/recent")
def recent_tickets(db: Session = Depends(get_db)):
    tickets = db.query(Ticket)\
        .order_by(Ticket.created_at.desc())\
        .limit(4)\
        .all()

    return tickets

# Delete a ticket by ID
@app.delete("/tickets/{ticket_id}")
def delete_ticket(ticket_id: str, db: Session = Depends(get_db)):
    ticket = db.query(Ticket).filter(Ticket.id == uuid.UUID(ticket_id)).first()
    
    if not ticket:
        return {"error": "not found"}
    
    db.delete(ticket)
    db.commit()

    return {"msg": "deleted"}

# Update ticket title and description
@app.put("/tickets/{ticket_id}")
def update_ticket(ticket_id: str, title: str, description: str, db: Session = Depends(get_db)):
    ticket = db.query(Ticket).filter(Ticket.id == ticket_id).first()

    if not ticket:
        return {"error": "not found"}
    
    ticket.title = title
    ticket.description = description

    db.commit()
    db.refresh(ticket)

    return ticket

# Get all tickets (for admin view)
@app.get("/tickets")
def get_tickets(db: Session = Depends(get_db)):
    tickets = db.query(Ticket).all()
    return tickets

# Get a single ticket by ID
@app.get("/tickets/{ticket_id}")
def get_ticket(ticket_id: str, db: Session = Depends(get_db)):
    ticket = db.query(Ticket).filter(Ticket.id == ticket_id).first()
    return ticket

# Generate AI summary based on the ticket content
@app.post("/tickets/{ticket_id}/summarize")
def summarize_ticket(ticket_id: str, db: Session = Depends(get_db)):
    ticket = db.query(Ticket).filter(Ticket.id == uuid.UUID(ticket_id)).first()

    if not ticket:
        return {"error": "not found"}

    text = f"""
    Summarize this support ticket in clean markdown format:

    {ticket.name}
    {ticket.email}
    {ticket.title}
    {ticket.description}
    """

    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": text}],
    )

    summary = response.choices[0].message.content
    log_action(db, ticket.id, "AI summary generated")

    return {"summary": summary}

# Reply generated by AI based on the ticket content
@app.post("/tickets/{ticket_id}/reply")
def generate_reply(ticket_id: str, db: Session = Depends(get_db)):
    ticket = db.query(Ticket).filter(Ticket.id == uuid.UUID(ticket_id)).first()

    if not ticket:
        return {"error": "not found"}

    prompt = f"""
    You are a helpful customer support agent.

    A user submitted this support request:
    {ticket.name}
    {ticket.email}
    {ticket.title}
    {ticket.description}

    Write a professional, helpful reply to the customer.
    Write reply in clean markdown format.
    """

    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": prompt}],
    )

    reply = response.choices[0].message.content
    log_action(db, ticket.id, "AI reply generated")

    return {"reply": reply}

# Update ticket status (e.g., OPEN, IN_PROGRESS, CLOSED)
@app.put("/tickets/{ticket_id}/status")
def update_status(ticket_id: str, status: str, db: Session = Depends(get_db)):
    ticket = db.query(Ticket).filter(Ticket.id == uuid.UUID(ticket_id)).first()

    if not ticket:
        return {"error": "not found"}

    ticket.status = status
    db.commit()
    log_action(db, ticket.id, f"Status changed to {status}")

    db.refresh(ticket)

    return {"msg": "updated", "status": ticket.status}

# Get dashboard statistics
@app.get("/dashboard/stats")
def dashboard_stats(db: Session = Depends(get_db)):
    tickets = db.query(Ticket).all()

    total = len(tickets)
    open_count = len([t for t in tickets if t.status == "OPEN"])
    progress = len([t for t in tickets if t.status == "IN_PROGRESS"])
    done = len([t for t in tickets if t.status == "DONE"])

    return {
        "total": total or 0,
        "open": open_count or 0,
        "in_progress": progress or 0,
        "done": done or 0
    }

# Get activity logs for a specific ticket
@app.get("/tickets/{ticket_id}/logs")
def get_logs(ticket_id: str, db: Session = Depends(get_db)):
    logs = db.query(ActivityLog)\
        .filter(ActivityLog.ticket_id == uuid.UUID(ticket_id))\
        .order_by(ActivityLog.timestamp.desc())\
        .all()

    return logs


